API de de supervision
#####################

Chaque composant :term:`VITAM` peut dialoguer, selon le paramétrage, via 2 réseaux :

* patte d'administration
* patte de service

Si les partitions ne possèdent qu'une seule interface, les deux "pattes" passent par cette unique interface.

Patte d'administration
======================
La solution logicielle :term:`VITAM` expose en interne de la plate-forme les :term:`API` :term:`REST` suivantes sur ses composants:

* ``/admin/v1/status`` : statut simple, renvoyant un statut de fonctionnement incluant des informations techniques sur l'état actuel du composant. Un exemple d'utilisation typique est l'intégration à un outil de supervision ou à un élément actif tiers (ex: load-balancer, ...) . L'appel doit être peu coûteux.
* ``/admin/v1/version`` : informations de version, build, commit git ayant servi à builder les différents jar.
* ``/admin/v1/autotest`` : autotest du composant, lançant un test de présence des différentes ressources requises par le composant et renvoyant un statut d'état de ces ressources.


/admin/v1/status
----------------
L'API de status renvoie un fichier JSON contenant les informations suivantes::


    {
        "serverIdentity": {
            "Name":"vitam-iaas-app-01",
            "Role":"logbook",
        "PlatformId":425367
        },
        "status":true,
        "detail": {
        },
            "componentsVersions": {
            "e2eb99d93a74409b3ebc5224e596953e9b8a178f":18
        }
    }

Signification des champs:

* serverIdentity
    * Name: hostname du serveur hébergeant le composant (type: texte)
    * Role: Nom du composant (type: texte)
    * PlatformId: ID de l'environnement (type: entier)
* status: Statut du composant (OK/KO) (type: booléen)
* detail: vide dans cette version, sera défini ultérieurement
* componentsVersions
    * hash de commit git: nombre de jars avec buildés depuis ce hash

/admin/v1/version
-----------------

L'API de version renvoie les informations suivantes::

    [
        {
            "Scm-tags":"",
            "Scm-commit-id":"e2eb99d93a74409b3ebc5224e596953e9b8a178f",
            "Scm-commit-id-abbrev":"e2eb99d",
            "Maven-version":"0.13.0-SNAPSHOT",
            "Scm-dirty":"false",
            "Scm-commit-time":"2017-01-11T16:38:14+01",
            "Maven-build-timestamp":"2017-01-11T16:06:09Z",
            "Scm-branch":"origin/master_iteration_13",
            "Build-Jdk":"1.8.0_111",
            "Maven-artefactId":"logbook-rest",
            "Maven-groupId":"fr.gouv.vitam"
        },
        {
            "Scm-tags":"",
            "Scm-commit-id":"e2eb99d93a74409b3ebc5224e596953e9b8a178f",
            "Scm-commit-id-abbrev":"e2eb99d",
            "Maven-version":"0.13.0-SNAPSHOT",
            "Scm-dirty":"false",
            "Scm-commit-time":"2017-01-11T16:38:14+01",
            "Maven-build-timestamp":"2017-01-11T16:06:09Z",
            "Scm-branch":"origin/master_iteration_13",
            "Build-Jdk":"1.8.0_111",
            "Maven-artefactId":"logbook-administration",
            "Maven-groupId":"fr.gouv.vitam"
        },
        ...
        ...
        ...
    ]

Signification des champs:

* Scm-tags: en cours de définition
* Scm-commit-id: hash de commit git à partir duquel le composant à été buildé
* Scm-commit-id-abbrev: hash de commit abrégé
* Maven-version: Version indiquée à maven dans le fichier pom.xml
* Scm-dirty: Etat du repo git au moment du build (si présence de fichiers unstaged => dirty)
* Scm-commit-time: Date du commit git
* Maven-build-timestamp: Date du build par maven
* Scm-branch: Nom de la branche git à partir de laquelle le composant a été buildé
* Build-Jdk: Version de la jdk ayant servit à builder le composant
* Maven-artefactId: Nom du composant
* Maven-groupId: namespace du composant

/admin/v1/autotest
------------------

L'API d'autotest renvoie les informations suivantes::

    {
        "httpCode":200,
        "code":"000000",
        "context":"logbook",
        "state":"OK",
        "message":"All services are available",
        "description":"All services are available",
        "errors": [
            {
                "httpCode":200,
                "code":"1",
                "context":"LogbookMongoDbAccessImpl",
                "state":"OK",
                "message":"Sub service is available",
                "description":"LogbookMongoDbAccessImpl service is available"
            },
            {
                "httpCode":200,
                "code":"2",
                "context":"logbook",
                "state":"OK",
                "message":"Internal service is available",
                "description":"vitam-iaas-app-01 service is available"
            }
        ]
    }

Signification des champs:

* **httpCode**: code de retour http
* **code**: en cours de définition ; futur code retour interne VITAM
* **context**: Nom du composant
* **state**: Etat du composant (OK/KO)
* **message**: Message de statut
* **description**: Message de description
* **errors**:
    * httpCode: code de retour http
    * code: code de retour
    * context: nom du composant
    * state: État du composant
    * message: Message sur l'état du composant
    * description: Description sur l'état du composant

Patte de service
================

* ``/<composant>/v1/status`` : statut simple, renvoyant un statut de fonctionnement incluant des informations techniques sur l'état actuel du composant. Un exemple d'utilisation typique est l'intégration à un outil de supervision ou à un élément actif tiers (ex: load-balancer, ...) . L'appel doit être peu coûteux. Le statut normal HTTP renvoyé est 204.


.. warning:: Les composants **vitam-elastic-kibana-interceptor**, **security-internal**, **library** et les :term:`IHM` ne possèdent pas ce statut.

.. note:: Pour le composant **security-internal**, le point d':term:`API` est ``/v1/status``.
